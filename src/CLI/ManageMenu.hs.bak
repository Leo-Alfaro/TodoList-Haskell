module CLI.ManageMenu (manageTasksMenu) where

import CLI.Common (getOption, invalidOption, parseError)
import Data.Time.Calendar (Day)
import TaskManager (addTask, createTask, markCompleted, removeTask, taskExists)
import Text.Read (readMaybe)
import Types

addTaskIO :: [Task] -> IO [Task]
addTaskIO tasks = do
  _getId
    >>= successState
      ( \_id ->
          _getDescription
            >>= ( successState
                    ( \_desc ->
                        _getPriority
                          >>= ( successState
                                  ( \_priority ->
                                      _getCategory
                                        >>= ( successState
                                                ( \_category ->
                                                    _getDeadline
                                                      >>= ( successState
                                                              ( \_deadline ->
                                                                  _getTags
                                                                    >>= ( successState
                                                                            ( \_tags ->
                                                                                return (addTask (createTask _id _desc Pending _priority _category _deadline _tags) tasks)
                                                                            )
                                                                        )
                                                              )
                                                          )
                                                )
                                            )
                                  )
                              )
                    )
                )
      )
  where
    successState f val = either errorState f val
    errorState err = putStrLn err >> return tasks

    checkId :: Maybe Int -> Either String Int
    checkId Nothing = Left parseError
    checkId (Just _id) =
      if taskExists tasks _id
        then Left "Já existe uma tarefa com esse Id"
        else Right _id
    checkPriority :: Maybe Int -> Either String Priority
    checkPriority Nothing = Left parseError
    checkPriority (Just num) = case num of
      1 -> Right Low
      2 -> Right Medium
      3 -> Right High
      _ -> Left invalidOption
    checkCategory :: Maybe Int -> Either String Category
    checkCategory Nothing = Left parseError
    checkCategory (Just cat) = case cat of
      1 -> Right Work
      2 -> Right Study
      3 -> Right Personal
      4 -> Right Other
      _ -> Left invalidOption

    checkDeadline :: (Maybe Day) -> Either String (Maybe Day)
    checkDeadline day = Right day

    checkTags :: [String] -> Either String [String]
    checkTags = Right

    _getTagsRepeat :: [String] -> IO [String]
    _getTagsRepeat ("" : xs) = return xs
    _getTagsRepeat _tags = do
      line <- getLine
      _getTagsRepeat (line : _tags)

    _getId = putStrLn "Digite o Id da Task:" >> checkId <$> (readMaybe <$> getLine)
    _getDescription :: IO (Either String String)
    _getDescription = putStrLn "Descrição da tarefa:" >> Right <$> getLine
    _getPriority = putStrLn "Prioridade da tarefa (1 - Baixa | 2 - Media | 3 - Alta):" >> checkPriority <$> (readMaybe <$> getLine)
    _getCategory = putStrLn "Categoria da tarefa (1 - Trabalho | 2 - Estudo | 3 - Pessoal | 4 - Outro):" >> checkCategory <$> (readMaybe <$> getLine)
    _getDeadline = putStrLn "Deadline da tarefa (vazio para tarefas sem deadline):" >> checkDeadline <$> (readMaybe <$> getLine)
    _getTags = putStrLn "Tags para a tarefa:" >> checkTags <$> (_getTagsRepeat [])

removeTaskIO :: [Task] -> IO [Task]
removeTaskIO tasks = do
  putStrLn "Digite o Id da task a ser removida:"
  maybeId <- readMaybe <$> getLine
  return (maybe tasks ((flip removeTask) tasks) maybeId)

markCompletedIO :: [Task] -> IO [Task]
markCompletedIO tasks = do
  putStrLn "Digite o Id da task a ser removida:"
  maybeId <- readMaybe <$> getLine
  return (maybe tasks ((flip markCompleted) tasks) maybeId)

manageTasksHelp :: String
manageTasksHelp = "1 - Adicionar tarefa\n2 - Remover tarefa\n3 - Marcar Tarefa como concluida\n0 - Voltar"

manageTasksMenu :: [Task] -> IO [Task]
manageTasksMenu tasks = do
  putStrLn manageTasksHelp
  option <- getOption
  _manageOptions option tasks
  where
    _manageOptions Nothing = (>>) (putStrLn parseError) . return
    _manageOptions (Just 0) = return
    _manageOptions (Just 1) = addTaskIO
    _manageOptions (Just 2) = removeTaskIO
    _manageOptions (Just 3) = markCompletedIO
    _manageOptions (Just _) = (>>) (putStrLn invalidOption) . return
